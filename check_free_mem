#!perl

# RCS information
# enable substitution with:
#   $ svn propset svn:keywords "Id Revision HeadURL Source Date"
#
#   $Id: check_dir 856 2007-10-31 09:34:21Z corti $
#   $Revision: 856 $
#   $HeadURL: https://svn.id.ethz.ch/nagios_plugins/check_dir/check_dir $
#   $Date: 2007-10-31 10:34:21 +0100 (Wed, 31 Oct 2007) $

use strict;
use warnings;

use 5.00800;

use Carp;
use English qw(-no_match_vars);
use File::Slurp;
use Getopt::Long;
use Monitoring::Plugin;
use Monitoring::Plugin::Threshold;
use Readonly;

our $VERSION = '1.0.1';

## no critic (ProhibitMagicNumbers)

# IMPORTANT: Nagios plugins could be executed using embedded perl in this case
#            the main routine would be executed as a subroutine and all the
#            declared subroutines would therefore be inner subroutines
#            This will cause all the global lexical variables not to stay shared
#            in the subroutines!
#
# All variables are therefore declared as package variables...
#
## no critic (ProhibitPackageVars)
use vars qw(
  $buffers
  $cached
  $critical
  $free
  $help
  $line
  $plugin
  $result
  $shared
  $swap
  $threshold
  $total
  $used
  $verbosity
  $warning
);

##############################################################################
# subroutines

##############################################################################
# Usage     : usage( -message => 'some text', -exitval => 1 )
# Purpose   : prints a usage message
# Returns   : n/a
# Arguments : -message : an optional error message
#             -exitval : the exit code (defaults to 0)
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub usage {

    my %args = @_;

    my $exitval = 0;
    if ( $args{-exitval} ) {
        $exitval = $args{-exitval};
    }

    if ( $args{-message} ) {
        #<<<
        print $args{-message}; ## no critic (RequireCheckedSyscall)
        #>>>
    }

    #<<<
    print <<'EOT'; ## no critic (RequireCheckedSyscall)
        check_free_mem --critical=critical --warning=warning
                   [--swap]
                   [--verbose]
                   [--version|--help]

        Mandatory arguments:
         --critical,-c   critical   specify the minumal percentage free memory
         --warning,-w    warning    specify warning threshold for the percentage of free memory

        Options:
         --swap,-s                  process also swap
         --version,V                print version number
         --verbose,-v               be more verbose (can be repeated)
EOT
    #>>>
    exit $exitval;

}

##############################################################################
# Usage     : verbose("some message string", $optional_verbosity_level);
# Purpose   : write a message if the verbosity level is high enough
# Returns   : n/a
# Arguments : message : message string
#             level   : options verbosity level
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub verbose {

    # arguments
    my $message = shift;
    my $level   = shift;

    if ( !defined $message ) {
        $plugin->nagios_exit( UNKNOWN,
            q{Internal error: not enough parameters for 'verbose'} );
    }

    if ( !defined $level ) {
        $level = 0;
    }

    if ( $level < $verbosity ) {
        #<<<
        print $message; ## no critic (RequireCheckedSyscall)
        #>>>
    }

    return;

}

##############################################################################
# Usage     : check_positive_integer($number)
# Purpose   : checks if the argument is a valid positive integer
# Returns   : true if the number is valid
# Arguments : number to test
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub check_positive_integer {
    my $number = shift;
    return $number =~ /^\d+$/mxs;
}

##############################################################################
# Usage     : get_path('program_name');
# Purpose   : retrieves the path of an executable file using the
#             'which' utility
# Returns   : the path of the program (if found)
# Arguments : the program name
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub get_path {

    my $prog = shift;
    my $path;

    my $which_command = "which $prog";
    my $which_output;

    #<<<
    open $which_output, q{-|}, "$which_command 2>&1"
      or $plugin->nagios_exit( UNKNOWN,  "Cannot execute $which_command: $OS_ERROR" );
    while (<$which_output>) {
        chomp;
        if ( !/^which:/mxs ) {
            $path = $_;
        }
    }
    if (  !( close $which_output )
        && ( $OS_ERROR != 0 ) )
    {

        # close to a piped open return false if the command with non-zero
        # status. In this case $! is set to 0
        $plugin->nagios_exit( UNKNOWN,
            "Error while closing pipe to $which_command: $OS_ERROR" );
    }
    #>>>
    return $path;

}

##############################################################################
# main

# initialization
$free      = q{};
$plugin    = Monitoring::Plugin->new( shortname => 'CHECK_FREE_MEM' );
$swap      = 0;
$verbosity = 0;

########################
# Command line arguments

Getopt::Long::Configure( 'bundling', 'no_ignore_case' );
$result = GetOptions(
    'free=s'       => \$free,
    'critical|c=i' => \$critical,
    'help|h|?'     => \$help,
    'swap|s'       => \$swap,
    'verbose|v+'   => \$verbosity,
    'version|V'    => sub {
        #<<<
        print "check_free_mem version $VERSION\n"; ## no critic (RequireCheckedSyscall)
        #>>>
        exit 3;
    },
    'warning|w=i' => \$warning,
);

#############################
# Sanity checks: command line

if ( !$result ) {
    usage( -exitval => UNKNOWN, );
}

if ($help) {
    usage( -exitval => UNKNOWN, );
}
if (   !defined $critical
    || !$critical =~ /\d+/mxs
    || $critical < 0
    || $critical > 100 )
{
    usage(
        -exitval => UNKNOWN,
        -message => 'Could not parse "critical"',
    );
}
if (   !defined $critical
    || !$warning =~ /\d+/mxs
    || $warning < 0
    || $warning > 100 )
{
    usage(
        -exitval => UNKNOWN,
        -message => 'Could not parse "warning"',
    );
}
if ( $critical > $warning ) {
    usage(
        -exitval => UNKNOWN,
        -message => '"critical" has to be smaller than "warning"',
    );
}

$threshold = Monitoring::Plugin::Threshold->set_thresholds(
    warning  => 100 - $warning,
    critical => 100 - $critical,
);

##########################
# Sanity checks: utilities

if ( !$free ) {
    $free = get_path('free');
}

if ( !$free ) {
    $plugin->nagios_exit( UNKNOWN, 'Unable to find the "free" utility"' );
}

if ( !-x $free ) {
    $plugin->nagios_exit( UNKNOWN, "$free is not executable" );
}

##################################
# get memory information from free

my $command = "$free -b -t";
my $output;

verbose "Executing \"$command\"\n";

my $pid = open $output, q{-|}, "$command 2>&1"
  or $plugin->nagios_exit( UNKNOWN, "Cannot execute $command: $OS_ERROR" );

# read the whole file
my @lines = read_file($output);

if (  !( close $output )
    && ( $OS_ERROR != 0 ) )
{

    # close to a piped open return false if the command with non-zero
    # status. In this case $! is set to 0
    $plugin->nagios_exit( UNKNOWN,
        "Error while closing pipe to $command: $OS_ERROR" );
}

if ( $verbosity > 1 ) {
    for my $line (@lines) {
        verbose "$line", 1;
    }
}

# process command outpt
# expexted format (example)
#
#              total       used       free     shared    buffers     cached
# Mem:     493817856  477454336   16363520          0   84209664   52895744
# -/+ buffers/cache:  340348928  153468928
# Swap:    534634496   27090944  507543552
# Total:  1028452352  504545280  523907072

# check the header
my $header = shift @lines;
if (   !$header
    || !$header =~
    /[ ]*total[ ]*used[ ]*free[ ]*shared[ ]*buffers[ ]*cached/mxs )
{
    $plugin->nagios_exit( UNKNOWN, 'Cannot recognize "free" output' );
}

# process real memory
my $dummy;
$line = shift @lines;
chomp $line;
( $dummy, $total, $used, $free, $shared, $buffers, $cached ) = split /[ ]+/mxs,
  $line;

if ( !check_positive_integer($total) ) {
    $plugin->nagios_exit( UNKNOWN,
        "Error processing free output: $total (total) is not a number" );
}
if ( !check_positive_integer($used) ) {
    $plugin->nagios_exit( UNKNOWN,
        "Error processing free output: $used (used) is not a number" );
}
if ( !check_positive_integer($free) ) {
    $plugin->nagios_exit( UNKNOWN,
        "Error processing free output: $free (free) is not a number" );
}
if ( !check_positive_integer($shared) ) {
    $plugin->nagios_exit( UNKNOWN,
        "Error processing free output: $shared (shared) is not a number" );
}
if ( !check_positive_integer($buffers) ) {
    $plugin->nagios_exit( UNKNOWN,
        "Error processing free output: $buffers (buffers) is not a number" );
}
if ( !check_positive_integer($cached) ) {
    $plugin->nagios_exit( UNKNOWN,
        "Error processing free output: $cached (cached) is not a number" );
}

if ($swap) {

    # use Totals instead of Mem for 'total', 'used' and 'free'

    shift @lines;    # skip +/- buffers/cache line

    $line = shift @lines;
    chomp $line;
    ( $dummy, $total, $used, $free ) = split /[ ]+/mxs, $line;

    if ( !check_positive_integer($total) ) {
        $plugin->nagios_exit( UNKNOWN,
            "Error processing free output: $total (total) is not a number" );
    }
    if ( !check_positive_integer($used) ) {
        $plugin->nagios_exit( UNKNOWN,
            "Error processing free output: $used (used) is not a number" );
    }
    if ( !check_positive_integer($free) ) {
        $plugin->nagios_exit( UNKNOWN,
            "Error processing free output: $free (free) is not a number" );
    }

    $plugin->add_perfdata(
        label => 'swap_total',
        value => $total,
        uom   => 'B',
    );

    $plugin->add_perfdata(
        label => 'swap_used',
        value => $used,
        uom   => 'B',
    );

    $plugin->add_perfdata(
        label => 'swap_free',
        value => $free,
        uom   => 'B',
    );

    $line = shift @lines;
    chomp $line;
    ( $dummy, $total, $used, $free ) = split /[ ]+/mxs, $line;

    if ( !check_positive_integer($total) ) {
        $plugin->nagios_exit( UNKNOWN,
            "Error processing free output: $total (total) is not a number" );
    }
    if ( !check_positive_integer($used) ) {
        $plugin->nagios_exit( UNKNOWN,
            "Error processing free output: $used (used) is not a number" );
    }
    if ( !check_positive_integer($free) ) {
        $plugin->nagios_exit( UNKNOWN,
            "Error processing free output: $free (free) is not a number" );
    }

}

$plugin->add_perfdata(
    label => 'total',
    value => $total,
    uom   => 'B',
);

$plugin->add_perfdata(
    label => 'used',
    value => $used,
    uom   => 'B',
);

$plugin->add_perfdata(
    label => 'free',
    value => $free,
    uom   => 'B',
);

$plugin->add_perfdata(
    label => 'buffers',
    value => $buffers,
    uom   => 'B',
);

$plugin->add_perfdata(
    label => 'cached',
    value => $cached,
    uom   => 'B',
);

# adjust buffers and caches and compute percentage

$free = ( $free + $buffers + $cached ) / $total * 100;

$plugin->nagios_exit(
    $threshold->get_status( 100 - $free ),
    'free ' . ( sprintf '%.2f', $free ) . q{%}
);

1;
